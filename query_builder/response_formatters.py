"""
Functions for formatting a response from a database query

Response formatters accept one required parameters and two optional parameters:
    result_set: list[dict] The result set from the query, generated by calling cursor.fetchall()
    pg_config: Optional[PostgresConfig] The configuration for the database connection. 
                This is used to fetch the column types for the tables in the result set.
                In the future consider prefetching the database schema and passing it instead of 
                a database configuration object.
    command: Optional[SQLCommand] The command that generated the result set
"""

from collections import namedtuple
from query_builder.utilities import decompose_row, dataclass_for_table


def default_response_formatter(
    result_set: list[dict], pg_config=None, command=None
) -> list[dict]:
    """
    Returns the result set as a list of dictionaries
    """
    return [dict(r) for r in result_set]


def decompose_dict_response_formatter(
    result_set: list[dict], pg_config=None, command=None
) -> tuple[list[dict], list[str]]:
    """
    Returns the result set as a tuple of a list of dictionaries and a list of the columns
    """
    return [decompose_row(r) for r in result_set]


def object_response_formatter(
    result_set: list[dict], pg_config=None, command=None
) -> list[object]:
    table_classes = {
        command._table_name: dataclass_for_table(command._table_name, pg_config)
    }
    decomposed = [decompose_row(r) for r in result_set]

    if not hasattr(command, "_join") or command._join is None:
        # If there is no join, return a list of objects for the primary table for each row
        # If the decomposed row does not have the table name as a key, use the row as the values
        return [
            table_classes[command._table_name](**(row[command._table_name] if command._table_name in row else row))
            for row in decomposed
        ]

    # If there is a join, create dataclasses for each table in the join
    for t in command._join.tables:
        table_classes[t] = dataclass_for_table(t, pg_config)

    Row = namedtuple("Row", table_classes.keys())

    # Looks complex, but it's just a list comprehension that creates a namedtuple for each row
    return [
        Row(**{tab: table_classes[tab](**values) for tab, values in row.items()})
        for row in decomposed
    ]


class RelationFormatter:
    """
    Formats a result set as a hierarchical set of objects based on the relations defined in this formatter
    """

    def __init__(self):
        self._relations = {}

    def set_relation(
        self, attribute_name: str, foreign_table: str, relationship_type: str = "many"
    ) -> "RelationFormatter":
        """
        Define a relation between two tables
        When formatting results, a new attribute will be added to an object based on the attribute_name
        The value of the attributed will be an object of the foreign_table

        The attribute name is specified as "tablename.attribute" where tablename is the name of the table 
        that the attribute belongs to

        The relationship_type is the type of relationship between the tables, either "one" or "many", 
        default is "many"
        """
        if "." not in attribute_name:
            raise ValueError(
                "Attribute name must be in the format 'tablename.attribute'"
            )

        self._relations[tuple(attribute_name.split("."))] = (
            foreign_table,
            relationship_type,
        )
        return self

    def format(
        self, result_set: list[dict], pg_config=None, command=None
    ) -> list[object]:
        """
        Format the result set as a hierarchical set of objects using the relation definitions
        The primary table is the root of the hierarchy for each row.
        """
        # Decompose the result set into a list of dictionaries
        # Each dictionary represents a row in the result set
        # and is keyed by table name, with values as dictionaries of column values
        # i.e. {"posts": {"id": 1, "title": "Post 1"}, "comments": {"id": 1, "post_id": 1, "comment": "Comment 1"}}
        decomposed_rows = decompose_dict_response_formatter(
            result_set, pg_config, command
        )

        obj_cache = []  # a cache of objects that have already been created
        response = []
        for row in decomposed_rows:
            for table, values in row.items():

                # Construct the row object for the current table
                row_obj = dataclass_for_table(table, pg_config)(**values)

                # If the table is the primary table, add the object to the response
                # otherwise, cache the object for use in relationships
                if table == command._table_name:
                    response_obj = next((r for r in response if r == row_obj), None)
                    if response_obj is None:
                        # If the root object is not already in the response, add it
                        response.append(row_obj)
                    else:
                        row_obj = response_obj
                else:
                    cached_obj = next((o for o in obj_cache if o == row_obj), None)
                    if cached_obj is None:
                        obj_cache.append(row_obj)
                    else:
                        row_obj = cached_obj

                # Add the foreign objects to the current row object
                for (attribute_table, attribute_name), (
                    foreign_table,
                    relationship_type,
                ) in self._relations.items():
                    # Skip if the attribute does not apply to the current table
                    if attribute_table != table:
                        continue

                    # Construct the object for the foreign table
                    foreign_obj = dataclass_for_table(foreign_table, pg_config)(
                        **row[foreign_table]
                    )
                    if foreign_obj in obj_cache:
                        foreign_obj = next((o for o in obj_cache if o == foreign_obj))
                    else:
                        obj_cache.append(foreign_obj)

                    if hasattr(row_obj, attribute_name):
                        # If the attribute already exists, convert it to a list and append the foreign object to the attribute
                        if relationship_type == "many":
                            getattr(row_obj, attribute_name).append(foreign_obj)
                        else:
                            setattr(row_obj, attribute_name, foreign_obj)
                    else:
                        # If the attribute does not exist, create it and set the foreign object as the value
                        if relationship_type == "many":
                            setattr(row_obj, attribute_name, [foreign_obj])
                        else:
                            print(
                                f"Setting {row_obj}.{attribute_name} to {foreign_obj}"
                            )
                            setattr(row_obj, attribute_name, foreign_obj)

        return response
