"""
Functions for formatting a response from a database query

Response formatters accept one required parameters and two optional parameters:
    result_set: list[dict] The result set from the query, generated by calling cursor.fetchall()
    pg_config: Optional[PostgresConfig] The configuration for the database connection. 
                This is used to fetch the column types for the tables in the result set.
                In the future consider prefetching the database schema and passing it instead of 
                a database configuration object.
    command: Optional[SQLCommand] The command that generated the result set
"""

from collections import namedtuple
from dataclasses import make_dataclass, field, dataclass
from typing import List
from query_builder.utilities import (
    decompose_row,
    dataclass_for_table,
    get_column_definitions,
    data_type_to_field_type
)


def default_response_formatter(
    result_set: list[dict], pg_config=None, command=None
) -> list[dict]:
    """
    Returns the result set as a list of dictionaries
    """
    return [dict(r) for r in result_set]


def decompose_dict_response_formatter(
    result_set: list[dict], pg_config=None, command=None
) -> tuple[list[dict], list[str]]:
    """
    Returns the result set as a tuple of a list of dictionaries and a list of the columns
    """
    return [decompose_row(r) for r in result_set]


def object_response_formatter(
    result_set: list[dict], pg_config=None, command=None
) -> list[object]:
    table_classes = {
        command._table_name: dataclass_for_table(command._table_name, pg_config)
    }
    decomposed = [decompose_row(r) for r in result_set]

    if not hasattr(command, "_join") or command._join is None:
        # If there is no join, return a list of objects for the primary table for each row
        # If the decomposed row does not have the table name as a key, use the row as the values
        return [
            table_classes[command._table_name](**(row[command._table_name] if command._table_name in row else row))
            for row in decomposed
        ]

    # If there is a join, create dataclasses for each table in the join
    for t in command._join.tables:
        table_classes[t] = dataclass_for_table(t, pg_config)

    Row = namedtuple("Row", table_classes.keys())

    # Looks complex, but it's just a list comprehension that creates a namedtuple for each row
    return [
        Row(**{tab: table_classes[tab](**values) for tab, values in row.items()})
        for row in decomposed
    ]


class RelationFormatter:
    """
    Formats a result set as a hierarchical set of objects based on the relations defined in this formatter
    """

    def __init__(self):
        self._relations = {}
        self._table_classes = {}

    def set_relation(
        self, attribute_name: str, foreign_table: str, relationship_type: str = "many"
    ) -> "RelationFormatter":
        """
        Define a relation between two tables
        When formatting results, a new attribute will be added to an object based on the attribute_name
        The value of the attributed will be an object of the foreign_table

        The attribute name is specified as "tablename.attribute" where tablename is the name of the table 
        that the attribute belongs to

        The relationship_type is the type of relationship between the tables, either "one" or "many", 
        default is "many"
        """
        if "." not in attribute_name:
            raise ValueError(
                "Attribute name must be in the format 'tablename.attribute'"
            )

        self._relations[tuple(attribute_name.split("."))] = (
            foreign_table,
            relationship_type,
        )
        return self
    
    def dataclass_for_table(self, table_name, pg_config):
        """
        A custom dataclass_for_table function that adds the relationships defined in this formatter
        This will not behave well if the table classes have circular references
        """
        if table_name in self._table_classes:
            return self._table_classes[table_name]
        
        column_defs = get_column_definitions(table_name, pg_config)

        base_fields = [
            (c.name, data_type_to_field_type(c.data_type, c.is_nullable))
            for c in column_defs
        ]
        
        extended_fields = []
        for (attribute_table, attribute_name), (foreign_table, relationship_type) in self._relations.items():
            if attribute_table == table_name:
                foreign_cls = self._table_classes.get(foreign_table, self.dataclass_for_table(foreign_table, pg_config))
                if relationship_type == "many":
                    extended_fields.append((attribute_name, List[foreign_cls], field(default_factory=list)))
                                        
                else:
                    extended_fields.append((attribute_name, foreign_cls, field(default=None)))
        
        fields = base_fields + extended_fields

        # Create the dataclass with all the fields but no equality method
        dc = make_dataclass(("Base" + table_name.title()), fields, eq=False)
        
        # Add an equality method that compares the base fields
        def __eq__(self, other):
            if not isinstance(other, dc):
                return False
            return all(getattr(self, f) == getattr(other, f) for f, _ in base_fields)
            
        self._table_classes[table_name] = dataclass(type(table_name.title(), (dc,), {"__eq__": __eq__}))
        return self._table_classes[table_name]


    def format(
        self, result_set: list[dict], pg_config=None, command=None
    ) -> list[object]:
        """
        Format the result set as a hierarchical set of objects using the relation definitions
        The primary table is the root of the hierarchy for each row.
        """
        # Decompose the result set into a list of dictionaries
        # Each dictionary represents a row in the result set
        # and is keyed by table name, with values as dictionaries of column values
        # i.e. {"posts": {"id": 1, "title": "Post 1"}, "comments": {"id": 1, "post_id": 1, "comment": "Comment 1"}}
        decomposed_rows = decompose_dict_response_formatter(
            result_set, pg_config, command
        )

        obj_cache = []  # a cache of objects that have already been created
        response = []
        for row in decomposed_rows:
            for table, values in row.items():

                # Construct the row object for the current table
                row_obj = self.dataclass_for_table(table, pg_config)(**values)

                # If the table is the primary table, add the object to the response
                # otherwise, cache the object for use in relationships
                if table == command._table_name:
                    response_obj = next((r for r in response if r == row_obj), None)
                    if response_obj is None:
                        # If the root object is not already in the response, add it
                        response.append(row_obj)
                    else:
                        row_obj = response_obj
                else:
                    cached_obj = next((o for o in obj_cache if o == row_obj), None)
                    if cached_obj is None:
                        obj_cache.append(row_obj)
                    else:
                        row_obj = cached_obj

                # Add the foreign objects to the current row object
                for (attribute_table, attribute_name), (
                    foreign_table,
                    relationship_type,
                ) in self._relations.items():
                    # Skip if the attribute does not apply to the current table
                    if attribute_table != table:
                        continue

                    # Construct the object for the foreign table
                    foreign_obj = self.dataclass_for_table(foreign_table, pg_config)(
                        **row[foreign_table]
                    )
                    if foreign_obj in obj_cache:
                        foreign_obj = next((o for o in obj_cache if o == foreign_obj))
                    else:
                        obj_cache.append(foreign_obj)

                    # If all attributes of the foreign_obj are None, set the foreign_obj to none
                    if all(v is None for v in row[foreign_table].values()):
                        foreign_obj = None

                    if hasattr(row_obj, attribute_name):
                        # If the attribute already exists, convert it to a list and append the foreign object to the attribute
                        if relationship_type == "many":
                            if foreign_obj:
                                getattr(row_obj, attribute_name).append(foreign_obj)
                        else:
                            setattr(row_obj, attribute_name, foreign_obj)
                    else:
                        # If the attribute does not exist, create it and set the foreign object as the value
                        if relationship_type == "many":
                            setattr(row_obj, attribute_name, [foreign_obj] if foreign_obj else [])
                        else:
                            setattr(row_obj, attribute_name, foreign_obj)

        return response
